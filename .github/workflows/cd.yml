name: CD Pipeline

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      manual_version:
        description: '可選：手動指定版本（格式：<prefix>_v主.中.次.流水_說明）'
        required: false
        type: string

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  STATE_IMAGE: ${{ github.repository_owner }}/sound-state-management
  ANALYSIS_IMAGE: ${{ github.repository_owner }}/sound-analysis-service

jobs:
  parse_version:
    name: 解析版本標籤
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.parse.outputs.tag }}
      env: ${{ steps.parse.outputs.env }}
      version: ${{ steps.parse.outputs.version }}
      desc: ${{ steps.parse.outputs.desc }}
      should_deploy: ${{ steps.parse.outputs.should_deploy }}
    steps:
      - name: 取得程式碼
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 解析 commit message 格式
        id: parse
        shell: bash
        run: |
          # 優先使用手動輸入，否則從 commit message 取得
          if [ -n "${{ inputs.manual_version }}" ]; then
            VERSION_STRING="${{ inputs.manual_version }}"
          else
            # 取得最新 commit message 的第一行
            VERSION_STRING=$(git log -1 --pretty=%s)
          fi

          echo "解析版本字串: $VERSION_STRING"

          # 檢查是否符合版本格式：{env}_v{主}.{中}.{次}.{流水}_{說明}
          if [[ "$VERSION_STRING" =~ ^(dev|staging|server_production|edge_production|edge_productio)_v([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)_(.+)$ ]]; then
            ENV_NAME="${BASH_REMATCH[1]}"
            VERSION="${BASH_REMATCH[2]}.${BASH_REMATCH[3]}.${BASH_REMATCH[4]}.${BASH_REMATCH[5]}"
            DESC="${BASH_REMATCH[6]}"
            
            # edge_productio* 視為 edge_production
            if [ "$ENV_NAME" = "edge_productio" ]; then ENV_NAME="edge_production"; fi

            SHOULD_DEPLOY="true"
            if [ "$ENV_NAME" = "dev" ]; then SHOULD_DEPLOY="false"; fi

            echo "Version format matched"
            echo "   環境: $ENV_NAME"
            echo "   版本: $VERSION"
            echo "   說明: $DESC"
            echo "   部署: $SHOULD_DEPLOY"
          else
            echo "Commit message does not match version format, skipping CD"
            echo "   格式應為: {env}_v{主}.{中}.{次}.{流水}_{說明}"
            echo "   例如: staging_v1.0.0.1_add_feature"
            SHOULD_DEPLOY="false"
            ENV_NAME=""
            VERSION=""
            DESC=""
            VERSION_STRING=""
          fi

          echo "tag=$VERSION_STRING" >> "$GITHUB_OUTPUT"
          echo "env=$ENV_NAME" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "desc=$DESC" >> "$GITHUB_OUTPUT"
          echo "should_deploy=$SHOULD_DEPLOY" >> "$GITHUB_OUTPUT"

  build_and_push:
    name: 建置並推送映像
    needs: parse_version
    if: needs.parse_version.outputs.should_deploy == 'true' && needs.parse_version.outputs.env != 'edge_production'
    runs-on: ubuntu-latest
    outputs:
      state_image: ${{ steps.image_names.outputs.state_image }}
      analysis_image: ${{ steps.image_names.outputs.analysis_image }}
    env:
      VERSION: ${{ needs.parse_version.outputs.version }}
      ENV_NAME: ${{ needs.parse_version.outputs.env }}
    steps:
      - name: 取得程式碼
        uses: actions/checkout@v4

      - name: 設定 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 設定映像名稱（轉換為小寫）
        id: image_names
        shell: bash
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "state_image=${{ env.REGISTRY }}/${OWNER_LOWER}/sound-state-management" >> "$GITHUB_OUTPUT"
          echo "analysis_image=${{ env.REGISTRY }}/${OWNER_LOWER}/sound-analysis-service" >> "$GITHUB_OUTPUT"

      - name: 登入 GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 建置 State Management
        uses: docker/build-push-action@v5
        with:
          context: .
          file: core/state_management/Dockerfile
          push: true
          tags: |
            ${{ steps.image_names.outputs.state_image }}:${{ env.VERSION }}
            ${{ steps.image_names.outputs.state_image }}:${{ env.ENV_NAME }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: 建置 Analysis Service
        uses: docker/build-push-action@v5
        with:
          context: .
          file: sub_system/analysis_service/Dockerfile
          push: true
          tags: |
            ${{ steps.image_names.outputs.analysis_image }}:${{ env.VERSION }}
            ${{ steps.image_names.outputs.analysis_image }}:${{ env.ENV_NAME }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy_staging:
    name: 部署到 Staging (Windows)
    needs:
      - parse_version
      - build_and_push
    if: needs.parse_version.outputs.env == 'staging'
    runs-on: [self-hosted, staging]
    env:
      VERSION: ${{ needs.parse_version.outputs.version }}
    steps:
      - name: 取得程式碼
        uses: actions/checkout@v4

      - name: 建立 .env 檔案
        shell: cmd
        run: |
          (
            echo MONGODB_HOST=${{ secrets.STAGING_MONGODB_HOST }}
            echo MONGODB_PORT=${{ secrets.STAGING_MONGODB_PORT }}
            echo MONGODB_USERNAME=${{ secrets.STAGING_MONGODB_USERNAME }}
            echo MONGODB_PASSWORD=${{ secrets.STAGING_MONGODB_PASSWORD }}
            echo MONGODB_DATABASE=${{ secrets.STAGING_MONGODB_DATABASE }}
            echo RABBITMQ_HOST=${{ secrets.STAGING_RABBITMQ_HOST }}
            echo RABBITMQ_PORT=${{ secrets.STAGING_RABBITMQ_PORT }}
            echo RABBITMQ_USERNAME=${{ secrets.STAGING_RABBITMQ_USERNAME }}
            echo RABBITMQ_PASSWORD=${{ secrets.STAGING_RABBITMQ_PASSWORD }}
            echo STATE_MANAGEMENT_PORT=${{ secrets.STAGING_STATE_MANAGEMENT_PORT }}
            echo STATE_MANAGEMENT_URL=${{ secrets.STAGING_STATE_MANAGEMENT_URL }}
          ) > .env

      - name: 登入 GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 拉取映像
        shell: cmd
        run: |
          docker pull ${{ needs.build_and_push.outputs.state_image }}:${{ env.VERSION }}
          docker pull ${{ needs.build_and_push.outputs.analysis_image }}:${{ env.VERSION }}

      - name: 啟動服務
        shell: cmd
        env:
          STATE_IMAGE: ${{ needs.build_and_push.outputs.state_image }}:${{ env.VERSION }}
          ANALYSIS_IMAGE: ${{ needs.build_and_push.outputs.analysis_image }}:${{ env.VERSION }}
        run: docker compose -f core/docker-compose.yml -f core/docker-compose.ci.yml --env-file .env up -d --remove-orphans mongodb rabbitmq state_management analysis_service

      - name: 查看容器狀態與日誌
        shell: cmd
        if: always()
        run: |
          echo === Container Status ===
          docker ps -a
          echo.
          echo === state_management logs ===
          docker logs core_state_management 2>&1 || echo No logs available
          echo.
          echo === analysis_service logs ===
          docker logs analysis_service 2>&1 || echo No logs available

      - name: 等待 state_management 容器就緒
        shell: cmd
        run: |
          echo Waiting for core_state_management container...
          for /L %%i in (1,1,30) do (
            docker inspect --format="{{.State.Running}}" core_state_management 2>nul | findstr "true" >nul && (
              echo Container is running
              exit /b 0
            )
            echo Attempt %%i/30 - waiting...
            ping -n 6 127.0.0.1 >nul
          )
          echo Container did not start in time
          docker logs core_state_management 2>&1
          exit /b 1

      - name: 初始化管理員帳號
        shell: cmd
        run: |
          for /L %%i in (1,1,5) do (
            docker compose -f core/docker-compose.yml exec -T state_management python init_admin.py --username admin --password "${{ secrets.ADMIN_PASSWORD }}" --email "${{ secrets.ADMIN_EMAIL }}" && exit /b 0
            echo Retry %%i/5...
            ping -n 11 127.0.0.1 >nul
          )
          exit /b 1

      - name: 健康檢查
        shell: cmd
        run: curl -f http://localhost:${{ secrets.STAGING_STATE_MANAGEMENT_PORT }}/health

  deploy_server_production:
    name: 部署到 Server Production
    needs:
      - parse_version
      - build_and_push
    if: needs.parse_version.outputs.env == 'server_production'
    runs-on: [self-hosted, server_production]
    env:
      VERSION: ${{ needs.parse_version.outputs.version }}
    steps:
      - name: 清理工作目錄（解決 Docker 產生的權限問題）
        shell: bash
        run: |
          echo "[Cleanup] Cleaning workspace..."
          WORKSPACE="${{ github.workspace }}"

          # 修復整個工作目錄的權限（包含子目錄）
          if [ -d "$WORKSPACE" ]; then
            echo "Fixing directory permissions: $WORKSPACE"
            sudo chown -R $(whoami):$(id -gn) "$WORKSPACE" || true
            sudo chmod -R u+rwX "$WORKSPACE" || true
          fi

          # 也修復上層目錄（actions-runner/_work/repo_name/）
          PARENT_DIR=$(dirname "$WORKSPACE")
          if [ -d "$PARENT_DIR" ]; then
            echo "Fixing parent directory permissions: $PARENT_DIR"
            sudo chown -R $(whoami):$(id -gn) "$PARENT_DIR" || true
            sudo chmod -R u+rwX "$PARENT_DIR" || true
          fi

          # 強制刪除 __pycache__ 和 .pyc 檔案
          if [ -d "$WORKSPACE" ]; then
            sudo find "$WORKSPACE" -type d -name '__pycache__' -exec rm -rf {} + 2>/dev/null || true
            sudo find "$WORKSPACE" -type f -name '*.pyc' -delete 2>/dev/null || true
          fi

          echo "[Cleanup] Done"

      - name: 取得程式碼
        uses: actions/checkout@v4

      - name: 建立 .env 檔案
        shell: bash
        run: |
          cat <<EOF > .env
          # Server Production 環境設定（由 GitHub Actions 自動產生）

          # MongoDB 設定
          MONGODB_HOST=${{ secrets.PRODUCTION_MONGODB_HOST }}
          MONGODB_PORT=${{ secrets.PRODUCTION_MONGODB_PORT }}
          MONGODB_USERNAME=${{ secrets.PRODUCTION_MONGODB_USERNAME }}
          MONGODB_PASSWORD=${{ secrets.PRODUCTION_MONGODB_PASSWORD }}
          MONGODB_DATABASE=${{ secrets.PRODUCTION_MONGODB_DATABASE }}

          # RabbitMQ 設定
          RABBITMQ_HOST=${{ secrets.PRODUCTION_RABBITMQ_HOST }}
          RABBITMQ_PORT=${{ secrets.PRODUCTION_RABBITMQ_PORT }}
          RABBITMQ_USERNAME=${{ secrets.PRODUCTION_RABBITMQ_USERNAME }}
          RABBITMQ_PASSWORD=${{ secrets.PRODUCTION_RABBITMQ_PASSWORD }}

          # State Management 設定
          STATE_MANAGEMENT_PORT=${{ secrets.PRODUCTION_STATE_MANAGEMENT_PORT }}
          STATE_MANAGEMENT_URL=${{ secrets.PRODUCTION_STATE_MANAGEMENT_URL }}
          EOF

          echo ".env file created"
          chmod 600 .env

      - name: 設定映像名稱（轉換為小寫）
        id: image_names
        shell: bash
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "state_image=${{ env.REGISTRY }}/${OWNER_LOWER}/sound-state-management" >> "$GITHUB_OUTPUT"
          echo "analysis_image=${{ env.REGISTRY }}/${OWNER_LOWER}/sound-analysis-service" >> "$GITHUB_OUTPUT"

      - name: 登入 GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 拉取映像
        shell: bash
        run: |
          docker pull ${{ steps.image_names.outputs.state_image }}:${{ env.VERSION }}
          docker pull ${{ steps.image_names.outputs.analysis_image }}:${{ env.VERSION }}

      - name: 產出部署覆蓋檔
        shell: bash
        run: |
          cat <<YAML > core/docker-compose.override.ci.yml
          services:
            state_management:
              image: ${{ steps.image_names.outputs.state_image }}:${{ env.VERSION }}
              command: ["python", "state_management_main.py"]
            analysis_service:
              image: ${{ steps.image_names.outputs.analysis_image }}:${{ env.VERSION }}
              container_name: analysis_service
              restart: unless-stopped
              env_file:
                - ../.env
              environment:
                MONGODB_HOST: \${MONGODB_HOST}
                MONGODB_PORT: \${MONGODB_PORT}
                MONGODB_USERNAME: \${MONGODB_USERNAME}
                MONGODB_PASSWORD: \${MONGODB_PASSWORD}
                MONGODB_DATABASE: \${MONGODB_DATABASE}
                RABBITMQ_HOST: \${RABBITMQ_HOST}
                RABBITMQ_PORT: \${RABBITMQ_PORT}
                STATE_MANAGEMENT_URL: \${STATE_MANAGEMENT_URL}
              volumes:
                - ../sub_system/analysis_service/logs:/app/logs
              depends_on:
                - mongodb
                - rabbitmq
          YAML

      - name: 部署
        shell: bash
        run: |
          docker compose -f core/docker-compose.yml -f core/docker-compose.override.ci.yml up -d --remove-orphans mongodb rabbitmq state_management analysis_service

      - name: 等待 MongoDB 就緒
        shell: bash
        run: |
          echo "Waiting for MongoDB to start..."
          for i in {1..30}; do
            if docker compose -f core/docker-compose.yml exec -T mongodb mongosh --port ${{ secrets.PRODUCTION_MONGODB_PORT }} --eval "db.adminCommand('ping')" 2>/dev/null; then
              echo "MongoDB is ready"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done

      - name: 初始化管理員帳號
        shell: bash
        run: |
          echo "Initializing admin account..."
          docker compose -f core/docker-compose.yml exec -T state_management python init_admin.py \
            --username admin \
            --password "${{ secrets.ADMIN_PASSWORD }}" \
            --email "${{ secrets.ADMIN_EMAIL }}"

      - name: 語法 smoke test
        shell: bash
        run: |
          docker run --rm ${{ steps.image_names.outputs.state_image }}:${{ env.VERSION }} python -m compileall /app
          docker run --rm ${{ steps.image_names.outputs.analysis_image }}:${{ env.VERSION }} python -m compileall /app

      - name: 健康檢查
        shell: bash
        run: |
          sleep 10
          curl -f http://localhost:${{ secrets.PRODUCTION_STATE_MANAGEMENT_PORT }}/health

      - name: 清理 Docker 產生的檔案權限（確保下次 CI 可正常運行）
        if: always()
        shell: bash
        run: |
          echo "[Cleanup] Cleaning file permissions..."
          sudo chown -R $(whoami):$(id -gn) "${{ github.workspace }}" || true
          sudo chown -R $(whoami):$(id -gn) "$(dirname '${{ github.workspace }}')" || true
          echo "[Cleanup] Done"

  deploy_edge_production:
    name: 部署 Edge Client 到 Edge Production
    needs:
      - parse_version
    if: needs.parse_version.outputs.env == 'edge_production'
    runs-on: [self-hosted, edge_production]
    env:
      VERSION: ${{ needs.parse_version.outputs.version }}
      EDGE_CLIENT_DIR: sub_system/edge_client
    steps:
      - name: 清理工作目錄
        shell: bash
        run: |
          echo "[Cleanup] Cleaning workspace..."
          WORKSPACE="${{ github.workspace }}"
          if [ -d "$WORKSPACE" ]; then
            sudo chown -R $(whoami):$(id -gn) "$WORKSPACE" || true
            sudo chmod -R u+rwX "$WORKSPACE" || true
          fi
          echo "[Cleanup] Done"

      - name: 取得程式碼
        uses: actions/checkout@v4

      - name: 停止現有服務（如果存在）
        shell: bash
        run: |
          if systemctl is-active --quiet edge-client; then
            echo "停止現有 edge-client 服務..."
            sudo systemctl stop edge-client
          fi

      - name: 設定 Python 虛擬環境
        shell: bash
        run: |
          cd ${{ env.EDGE_CLIENT_DIR }}

          # 建立或更新 venv
          if [ ! -d "venv" ]; then
            echo "建立 Python 虛擬環境..."
            python3 -m venv venv
          fi

          # 安裝依賴
          echo "安裝依賴..."
          ./venv/bin/pip install --upgrade pip
          ./venv/bin/pip install -r requirements.txt

      - name: 自動生成 device_config.json
        shell: bash
        run: |
          cd ${{ env.EDGE_CLIENT_DIR }}

          # 獲取 hostname 作為 device_name
          DEVICE_NAME=$(hostname)

          # 保留現有 device_id 或生成新的
          EXISTING_ID=""
          if [ -f "device_config.json" ]; then
            EXISTING_ID=$(python3 -c "import json; print(json.load(open('device_config.json')).get('device_id', ''))" 2>/dev/null || echo "")
          fi

          if [ -z "$EXISTING_ID" ]; then
            DEVICE_ID=$(python3 -c "import uuid; print(str(uuid.uuid4()))")
          else
            DEVICE_ID="$EXISTING_ID"
          fi

          # 生成 device_config.json
          cat > device_config.json << EOF
          {
            "device_id": "${DEVICE_ID}",
            "device_name": "${DEVICE_NAME}",
            "server_url": "${{ secrets.EDGE_SERVER_URL }}",
            "audio_config": {
              "default_device_index": 0,
              "channels": 1,
              "sample_rate": 16000,
              "bit_depth": 32
            },
            "heartbeat_interval": 30,
            "reconnect_delay": 5,
            "max_reconnect_delay": 60,
            "temp_wav_dir": "temp_wav"
          }
          EOF

          echo "device_config.json 已生成:"
          cat device_config.json

      - name: 建立暫存目錄
        shell: bash
        run: |
          mkdir -p ${{ env.EDGE_CLIENT_DIR }}/temp_wav
          chmod 755 ${{ env.EDGE_CLIENT_DIR }}/temp_wav

      - name: 安裝 systemd service
        shell: bash
        run: |
          WORK_DIR="${{ github.workspace }}/${{ env.EDGE_CLIENT_DIR }}"
          VENV_PYTHON="${WORK_DIR}/venv/bin/python"

          # 動態生成 service 文件
          cat > /tmp/edge-client.service << EOF
          [Unit]
          Description=Sound Analysis Edge Client
          After=network-online.target sound.target
          Wants=network-online.target

          [Service]
          Type=simple
          User=$(whoami)
          WorkingDirectory=${WORK_DIR}
          ExecStart=${VENV_PYTHON} edge_client.py
          Restart=always
          RestartSec=10
          StandardOutput=journal
          StandardError=journal

          [Install]
          WantedBy=multi-user.target
          EOF

          # 安裝 service
          sudo cp /tmp/edge-client.service /etc/systemd/system/edge-client.service
          sudo systemctl daemon-reload

      - name: 啟用並啟動服務
        shell: bash
        run: |
          sudo systemctl enable edge-client
          sudo systemctl start edge-client

          # 等待服務啟動
          sleep 5

      - name: 驗證服務狀態
        shell: bash
        run: |
          echo "=== 服務狀態 ==="
          sudo systemctl status edge-client --no-pager

          echo ""
          echo "=== 最近日誌 ==="
          sudo journalctl -u edge-client -n 20 --no-pager

